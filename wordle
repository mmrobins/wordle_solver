#!/usr/bin/env ruby

# TODO add a --show-steps flag to show words for each guess

guess_word = ARGV[0].to_s
guess_result = ARGV[1].to_s

doc = <<-HEREDOC
  run this with 2 args per guess, the guess word and guess result

  e.g. one guess:

    $ ./wordle their xo~~x
    Guess word: their
    Guess result: xo~~x
    22 possible words:

    cheki
    chide
    chief
    ...

  e.g. two guesses:

    $ ./wordle their xo~~x whine oooxo
    Guess word: their
    Guess result: xo~~x
    7 possible words

    Guess word: whine
    Guess result: oooxo
    1 possible words

    while

  and you'll get the remaining possible words as output

  Guess words must be 5 letters

  Guess results must be 5 charactes of the form

    x = letter miss
    o = letter hit in right place
    ~ = letter hit in wrong place
HEREDOC

guesses = ARGV.each_slice(2).to_a

guesses.each do |guess_word, guess_result|
  if guess_word.to_s !~ /^[a-zA-Z]{5}$/
    puts "Bad guess word '#{guess_word}'\n\n"
    puts doc
    exit 1
  end
  if guess_result.to_s !~ /^[xo~]{5}$/
    puts "Bad guess result '#{guess_result}' (guess word #{guess_word})\n\n"
    puts doc
    exit 1
  end
end

# this has some weird words wordle doesn't use, but can't find a better source easily
def use_full_dictionary
  dictionary_location = './words_alpha.txt'
  unless File.exists?(dictionary_location)
    require 'open-uri'
    download = URI.open('https://github.com/dwyl/english-words/raw/master/words_alpha.txt')
    IO.copy_stream(download, dictionary_location) # maybe put in tmp dir?
  end

  # could store this off in another file, but it's super fast anyway
  File.
    readlines(dictionary_location).
    map(&:strip).
    select {|w| w.length == 5 }
end

# WARNING this could get out of date
# manually pulled this out of https://www.powerlanguage.co.uk/wordle/main.db1931a8.js
# stored in a 'var Aa=["list","of","words"]; var La=[]' variables :-/
# theoretically could automate 
# 1. parsing the html
# 2. finding the js file (might change names since it appears to have hash in name)
# 3. find where Aa La vars are assigned, parse that
def use_hacked_wordle_dictionary
  File.readlines("./manual_wordle_list.txt").map(&:strip)
end

# TODO could make this use a flag or something to toggle between dictionary
five_letter_words = use_hacked_wordle_dictionary
#five_letter_words = use_full_dictionary

# simple score based on letter count in the word list
def build_word_scores(word_list)
  letter_frequency = {}

  word_list.each do |w|
    w.each_char do |c|
      letter_frequency[c] ||= 0
      letter_frequency[c] += 1
    end
  end

  letter_frequency.sort_by {|c, count| count}

  word_list.map do |w|
    score = w.
      chars.
      uniq. # duplicate chars don't provide extra info
      map {|c| letter_frequency[c]}.
      sum
    [w, score]
  end.to_h
end

def apply_guess(guess_word, guess_result, possible_words)
  puts "Guess word: #{guess_word}"
  puts "Guess result: #{guess_result}"

  guess_result.each_char.with_index do |char, i|
    guess_char = guess_word[i]

    if char == '~'
      possible_words.select! do |w|
        w[i] != guess_char && w.include?(guess_word[i])
      end
    elsif char == 'x'
      possible_words.reject! {|w| w.include?(guess_word[i])}
    elsif char == 'o'
      possible_words.select! {|w| w[i] == guess_char }
    else
      puts "not sure how to handle a guess with the character #{char}"
    end
  end


  puts "#{possible_words.count} possible words\n\n"
  possible_words
end

word_scores = build_word_scores(five_letter_words)

possible_words = five_letter_words

guesses.each do |guess_word, guess_result|
  possible_words = apply_guess(guess_word, guess_result, possible_words)
end

words_to_show = 20
top_n_index = [words_to_show, possible_words.count].min

top_n_possible_words = possible_words.
  map {|pw| [pw, word_scores[pw]]}.
  sort_by {|pw, word_score| word_score}[-(top_n_index)..-1]

top_n_possible_words.
  each {|pw, score| puts "#{pw} - #{score}"}

words_limited = possible_words.count > words_to_show ?
  " (only showing top #{words_to_show} scoring words)" :
  ""

puts
puts "#{possible_words.count} possible words#{words_limited}"
